# ğŸ—ºï¸ Road Map: Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ù…Ù†Ø·Ù‚ Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ… Ø¨Ø§ Ø³Ø§Ø®ØªØ§Ø± Ù…Ø§Ú˜ÙˆÙ„Ø§Ø±

**ØªØ§Ø±ÛŒØ® Ø´Ø±ÙˆØ¹**: 2025-01-20
**Ø²Ù…Ø§Ù† ØªØ®Ù…ÛŒÙ†ÛŒ**: 10-12 Ø±ÙˆØ² Ú©Ø§Ø±ÛŒ
**ÙˆØ¶Ø¹ÛŒØª**: Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÛŒÛŒØ¯

---

## â“ Ø³ÙˆØ§Ù„Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ (Ø¨Ø§ÛŒØ¯ Ù‚Ø¨Ù„ Ø§Ø² Ø´Ø±ÙˆØ¹ Ù¾Ø§Ø³Ø® Ø¯Ø§Ø¯Ù‡ Ø´ÙˆÙ†Ø¯)

### 1. Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ
- [ ] **Ø³ÙˆØ§Ù„ 1**: Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ ØªØºÛŒÛŒØ±Ø§Øª Ø±Ø§ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ø¯Ø± `signal_generation/` ÙØ¹Ù„ÛŒ Ø§Ø¹Ù…Ø§Ù„ Ú©Ù†ÛŒÙ…ØŸ
  - Ú¯Ø²ÛŒÙ†Ù‡ A: âœ… Ø¨Ù„Ù‡ØŒ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒÙ… (Ø³Ø±ÛŒØ¹â€ŒØªØ±)
  - Ú¯Ø²ÛŒÙ†Ù‡ B: ÛŒÚ© branch Ø¬Ø¯ÛŒØ¯ Ø¨Ø³Ø§Ø²ÛŒÙ… Ùˆ Ø¨Ø¹Ø¯ merge Ú©Ù†ÛŒÙ…
  - Ú¯Ø²ÛŒÙ†Ù‡ C: ÛŒÚ© Ù¾ÙˆØ´Ù‡ Ø¬Ø¯ÛŒØ¯ Ù…Ø«Ù„ `signal_generation_v2/` Ø¨Ø³Ø§Ø²ÛŒÙ…

  **Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯**: Ú¯Ø²ÛŒÙ†Ù‡ B (branch Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ safety)

### 2. Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Testing
- [ ] **Ø³ÙˆØ§Ù„ 2**: Ú†Ù‡ Ø²Ù…Ø§Ù†ÛŒ unit test Ù‡Ø§ Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒÙ…ØŸ
  - Ú¯Ø²ÛŒÙ†Ù‡ A: âœ… Ù‡Ù…Ø²Ù…Ø§Ù† Ø¨Ø§ Ù‡Ø± Ù…Ø±Ø­Ù„Ù‡ (Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒØŒ Ø§Ù…Ø§ Ú©Ù†Ø¯ØªØ±)
  - Ú¯Ø²ÛŒÙ†Ù‡ B: Ø¨Ø¹Ø¯ Ø§Ø² ØªÙ…Ø§Ù… Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒâ€ŒÙ‡Ø§ (Ø³Ø±ÛŒØ¹â€ŒØªØ±ØŒ Ø§Ù…Ø§ Ø®Ø·Ø±Ù†Ø§Ú©â€ŒØªØ±)
  - Ú¯Ø²ÛŒÙ†Ù‡ C: ÙÙ‚Ø· integration tests Ø¯Ø± Ù¾Ø§ÛŒØ§Ù†

  **Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯**: Ú¯Ø²ÛŒÙ†Ù‡ A (TDD approach)

### 3. Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Git
- [ ] **Ø³ÙˆØ§Ù„ 3**: Ú†Ø·ÙˆØ± commit Ú©Ù†ÛŒÙ…ØŸ
  - Ú¯Ø²ÛŒÙ†Ù‡ A: âœ… Ø¨Ø¹Ø¯ Ø§Ø² Ù‡Ø± Ù…Ø±Ø­Ù„Ù‡ ÛŒÚ© commit (Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ)
  - Ú¯Ø²ÛŒÙ†Ù‡ B: Ù‡Ø± Ø±ÙˆØ² ÛŒÚ© commit
  - Ú¯Ø²ÛŒÙ†Ù‡ C: Ø¯Ø± Ù¾Ø§ÛŒØ§Ù† ÛŒÚ©Ø¬Ø§

  **Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯**: Ú¯Ø²ÛŒÙ†Ù‡ A

### 4. Configuration Management
- [ ] **Ø³ÙˆØ§Ù„ 4**: Ú†Ø·ÙˆØ± Ø¨Ø§ config Ú©Ø§Ø± Ú©Ù†ÛŒÙ…ØŸ
  - Ú¯Ø²ÛŒÙ†Ù‡ A: âœ… Config ÙØ¹Ù„ÛŒ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒÙ…
  - Ú¯Ø²ÛŒÙ†Ù‡ B: `config_old_system.yaml` Ø¬Ø¯ÛŒØ¯ Ø¨Ø³Ø§Ø²ÛŒÙ…
  - Ú¯Ø²ÛŒÙ†Ù‡ C: Flag Ø¯Ø± config: `use_old_system_logic: true`

  **Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯**: Ú¯Ø²ÛŒÙ†Ù‡ C (backward compatible)

### 5. Validation Strategy
- [ ] **Ø³ÙˆØ§Ù„ 5**: Ú†Ø·ÙˆØ± ØµØ­Øª Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒÙ…ØŸ
  - Ú¯Ø²ÛŒÙ†Ù‡ A: Ù…Ù‚Ø§ÛŒØ³Ù‡ output Ø¨Ø§ Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ… (Ø¨Ø§ Ù‡Ù…Ø§Ù† input)
  - Ú¯Ø²ÛŒÙ†Ù‡ B: âœ… Backtest Ùˆ Ù…Ù‚Ø§ÛŒØ³Ù‡ Ù†ØªØ§ÛŒØ¬
  - Ú¯Ø²ÛŒÙ†Ù‡ C: ÙÙ‚Ø· manual testing

  **Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯**: Ú¯Ø²ÛŒÙ†Ù‡ A + B

### 6. Data for Testing
- [ ] **Ø³ÙˆØ§Ù„ 6**: Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ³Øª Ø§Ø² Ú©Ø¬Ø§ØŸ
  - Ú¯Ø²ÛŒÙ†Ù‡ A: Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ø² exchange
  - Ú¯Ø²ÛŒÙ†Ù‡ B: Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡ (CSV/Pickle)
  - Ú¯Ø²ÛŒÙ†Ù‡ C: Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ mock

  **ØªÙˆØ¶ÛŒØ­**: Ø¨Ø±Ø§ÛŒ Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ…ØŒ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ù‡Ù…Ø§Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù‡Ø³ØªÛŒÙ…

---

## ğŸ“‹ Overview: Ù…Ø±Ø§Ø­Ù„ Ú©Ù„ÛŒ

```
Phase 0: Preparation        (1 Ø±ÙˆØ²)  â† Setup + Questions
Phase 1: Foundation         (2 Ø±ÙˆØ²)  â† RiskCalculator + Analyzer fixes
Phase 2: Core Logic         (3 Ø±ÙˆØ²)  â† Scoring + Multi-TF
Phase 3: Integration        (2 Ø±ÙˆØ²)  â† Orchestrator + Config
Phase 4: Testing            (2 Ø±ÙˆØ²)  â† Unit + Integration tests
Phase 5: Validation         (1 Ø±ÙˆØ²)  â† Compare with old system
Phase 6: Documentation      (1 Ø±ÙˆØ²)  â† Final docs + handover
```

**Ø¬Ù…Ø¹**: 12 Ø±ÙˆØ² Ú©Ø§Ø±ÛŒ

---

## ğŸš€ Phase 0: Preparation (Ø±ÙˆØ² 0 - 1 Ø±ÙˆØ²)

### Ù‡Ø¯Ù
Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…Ø­ÛŒØ·ØŒ Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ØŒ Ùˆ Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø¯Ù‚ÛŒÙ‚

### Tasks

#### Task 0.1: Ù¾Ø§Ø³Ø® Ø¨Ù‡ Ø³ÙˆØ§Ù„Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ âœ‹
- [ ] Ù¾Ø§Ø³Ø® Ø¯Ø§Ø¯Ù† Ø¨Ù‡ 6 Ø³ÙˆØ§Ù„ Ø¨Ø§Ù„Ø§
- [ ] ØªØµÙ…ÛŒÙ…â€ŒÚ¯ÛŒØ±ÛŒ Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ
- [ ] Ù…Ø³ØªÙ†Ø¯Ø³Ø§Ø²ÛŒ ØªØµÙ…ÛŒÙ…Ø§Øª Ø¯Ø± Ø§ÛŒÙ† ÙØ§ÛŒÙ„

#### Task 0.2: Ø§ÛŒØ¬Ø§Ø¯ Branch Ø¬Ø¯ÛŒØ¯
```bash
# Ø§ÛŒØ¬Ø§Ø¯ branch Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±
git checkout -b feature/restore-old-system-logic

# ÛŒØ§ Ø§Ú¯Ø± Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø§Ø² main/master Ø´Ø±ÙˆØ¹ Ú©Ù†ÛŒØ¯
git checkout main
git pull origin main
git checkout -b feature/restore-old-system-logic
```

**Output**: Branch Ø¬Ø¯ÛŒØ¯ `feature/restore-old-system-logic`

#### Task 0.3: Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Test Data
- [ ] ØªÙ‡ÛŒÙ‡ 5-10 Ù†Ù…ÙˆÙ†Ù‡ Ø¯Ø§Ø¯Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ³Øª
- [ ] Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± `tests/data/sample_ohlcv/`
- [ ] ÙØ±Ù…Øª: `{symbol}_{timeframe}.csv`

**Ù…Ø«Ø§Ù„**:
```
tests/data/sample_ohlcv/
â”œâ”€â”€ BTCUSDT_5m.csv
â”œâ”€â”€ BTCUSDT_15m.csv
â”œâ”€â”€ BTCUSDT_1h.csv
â”œâ”€â”€ BTCUSDT_4h.csv
â”œâ”€â”€ ETHUSDT_5m.csv
â””â”€â”€ ...
```

#### Task 0.4: Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Old System Output (Ø¨Ø±Ø§ÛŒ Ù…Ù‚Ø§ÛŒØ³Ù‡)
- [ ] Ø§Ø¬Ø±Ø§ÛŒ Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ… Ø¨Ø§ Ù‡Ù…Ø§Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ³Øª
- [ ] Ø°Ø®ÛŒØ±Ù‡ Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ Ø¯Ø± `tests/expected_outputs/old_system/`
- [ ] ÙØ±Ù…Øª: JSON Ø¨Ø§ ØªÙ…Ø§Ù… Ø¬Ø²Ø¦ÛŒØ§Øª (SL, TP, score, patterns, ...)

**ÙØ§ÛŒÙ„ Ù†Ù…ÙˆÙ†Ù‡**: `tests/expected_outputs/old_system/BTCUSDT_signal.json`
```json
{
  "symbol": "BTCUSDT",
  "direction": "long",
  "entry_price": 50000.0,
  "stop_loss": 49500.0,
  "take_profit": 51000.0,
  "risk_reward_ratio": 2.0,
  "sl_method": "Harmonic_butterfly",
  "score": {
    "final_score": 75.5,
    "base_score": 25.0,
    "timeframe_weight": 1.3,
    "trend_alignment": 1.2,
    ...
  },
  "pattern_names": ["harmonic_butterfly", "rsi_bullish_divergence"],
  "timeframe_scores": {
    "5m": {"bullish": 15, "bearish": 5},
    "15m": {"bullish": 18, "bearish": 3},
    "1h": {"bullish": 22, "bearish": 2},
    "4h": {"bullish": 25, "bearish": 1}
  }
}
```

#### Task 0.5: Setup Testing Framework
```bash
# Ù†ØµØ¨ pytest Ø§Ú¯Ø± Ù†ÛŒØ³Øª
pip install pytest pytest-asyncio pytest-cov

# Ø§ÛŒØ¬Ø§Ø¯ Ø³Ø§Ø®ØªØ§Ø± tests
mkdir -p tests/unit/signal_generation
mkdir -p tests/integration
mkdir -p tests/data/sample_ohlcv
mkdir -p tests/expected_outputs/old_system
mkdir -p tests/expected_outputs/new_system
```

#### Task 0.6: Ø§ÛŒØ¬Ø§Ø¯ Utility Functions Ø¨Ø±Ø§ÛŒ ØªØ³Øª
**ÙØ§ÛŒÙ„**: `tests/utils/comparison.py`

```python
"""Utilities for comparing old and new system outputs."""
import json
from typing import Dict, Any, List
from dataclasses import dataclass

@dataclass
class ComparisonResult:
    """Ù†ØªÛŒØ¬Ù‡ Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¯Ùˆ Ø³ÛŒÚ¯Ù†Ø§Ù„"""
    matches: bool
    differences: List[Dict[str, Any]]
    score_diff_percentage: float
    sl_diff_percentage: float
    tp_diff_percentage: float

def compare_signals(
    old_signal: Dict[str, Any],
    new_signal: Dict[str, Any],
    tolerance: float = 0.05  # 5% tolerance
) -> ComparisonResult:
    """
    Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¯Ùˆ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ùˆ ÛŒØ§ÙØªÙ† ØªÙØ§ÙˆØªâ€ŒÙ‡Ø§.

    Args:
        old_signal: Ø®Ø±ÙˆØ¬ÛŒ Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ…
        new_signal: Ø®Ø±ÙˆØ¬ÛŒ Ø³ÛŒØ³ØªÙ… Ø¬Ø¯ÛŒØ¯
        tolerance: Ø­Ø¯ ØªÙ„Ø±Ø§Ù†Ø³ Ø¨Ø±Ø§ÛŒ ØªÙØ§ÙˆØªâ€ŒÙ‡Ø§ (5% Ù¾ÛŒØ´â€ŒÙØ±Ø¶)

    Returns:
        ComparisonResult Ø¨Ø§ Ø¬Ø²Ø¦ÛŒØ§Øª ØªÙØ§ÙˆØªâ€ŒÙ‡Ø§
    """
    differences = []

    # Ù…Ù‚Ø§ÛŒØ³Ù‡ direction
    if old_signal['direction'] != new_signal['direction']:
        differences.append({
            'field': 'direction',
            'old': old_signal['direction'],
            'new': new_signal['direction']
        })

    # Ù…Ù‚Ø§ÛŒØ³Ù‡ SL
    sl_diff_pct = abs(old_signal['stop_loss'] - new_signal['stop_loss']) / old_signal['stop_loss']
    if sl_diff_pct > tolerance:
        differences.append({
            'field': 'stop_loss',
            'old': old_signal['stop_loss'],
            'new': new_signal['stop_loss'],
            'diff_pct': sl_diff_pct * 100
        })

    # Ù…Ù‚Ø§ÛŒØ³Ù‡ TP
    tp_diff_pct = abs(old_signal['take_profit'] - new_signal['take_profit']) / old_signal['take_profit']
    if tp_diff_pct > tolerance:
        differences.append({
            'field': 'take_profit',
            'old': old_signal['take_profit'],
            'new': new_signal['take_profit'],
            'diff_pct': tp_diff_pct * 100
        })

    # Ù…Ù‚Ø§ÛŒØ³Ù‡ Score
    score_diff_pct = abs(old_signal['score']['final_score'] - new_signal['score']['final_score']) / old_signal['score']['final_score']
    if score_diff_pct > tolerance:
        differences.append({
            'field': 'score.final_score',
            'old': old_signal['score']['final_score'],
            'new': new_signal['score']['final_score'],
            'diff_pct': score_diff_pct * 100
        })

    # Ù…Ù‚Ø§ÛŒØ³Ù‡ SL method
    if old_signal.get('sl_method') != new_signal.get('sl_method'):
        differences.append({
            'field': 'sl_method',
            'old': old_signal.get('sl_method'),
            'new': new_signal.get('sl_method')
        })

    # Ù…Ù‚Ø§ÛŒØ³Ù‡ patterns
    old_patterns = set(old_signal.get('pattern_names', []))
    new_patterns = set(new_signal.get('pattern_names', []))
    if old_patterns != new_patterns:
        differences.append({
            'field': 'pattern_names',
            'old': list(old_patterns),
            'new': list(new_patterns),
            'missing_in_new': list(old_patterns - new_patterns),
            'extra_in_new': list(new_patterns - old_patterns)
        })

    return ComparisonResult(
        matches=(len(differences) == 0),
        differences=differences,
        score_diff_percentage=score_diff_pct * 100,
        sl_diff_percentage=sl_diff_pct * 100,
        tp_diff_percentage=tp_diff_pct * 100
    )

def load_expected_signal(symbol: str, test_case: str = "default") -> Dict[str, Any]:
    """Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ø² Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ…."""
    path = f"tests/expected_outputs/old_system/{symbol}_{test_case}.json"
    with open(path, 'r') as f:
        return json.load(f)
```

**Deliverables Phase 0**:
- [x] Branch Ø¬Ø¯ÛŒØ¯ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯Ù‡
- [ ] Test data Ø¢Ù…Ø§Ø¯Ù‡ Ø´Ø¯Ù‡ (5-10 Ù†Ù…ÙˆÙ†Ù‡)
- [ ] Expected outputs Ø§Ø² Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ… Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡
- [ ] Testing framework setup Ø´Ø¯Ù‡
- [ ] Comparison utilities Ù†ÙˆØ´ØªÙ‡ Ø´Ø¯Ù‡
- [ ] ØªØµÙ…ÛŒÙ…Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ Ù…Ø³ØªÙ†Ø¯ Ø´Ø¯Ù‡

**Checkpoint 0**:
```bash
# Ø¨Ø±Ø±Ø³ÛŒ Ø¢Ù…Ø§Ø¯Ú¯ÛŒ
ls tests/data/sample_ohlcv/  # Ø¨Ø§ÛŒØ¯ 20+ ÙØ§ÛŒÙ„ CSV Ø¨Ø§Ø´Ø¯
ls tests/expected_outputs/old_system/  # Ø¨Ø§ÛŒØ¯ 5-10 ÙØ§ÛŒÙ„ JSON Ø¨Ø§Ø´Ø¯
pytest tests/utils/test_comparison.py  # Ø¨Ø§ÛŒØ¯ pass Ø´ÙˆØ¯
git status  # Ù‡Ù…Ù‡ Ú†ÛŒØ² commit Ø´Ø¯Ù‡
```

---

## ğŸ”§ Phase 1: Foundation (Ø±ÙˆØ² 1-2ØŒ 2 Ø±ÙˆØ²)

### Ù‡Ø¯Ù
Ø§ÛŒØ¬Ø§Ø¯ Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ÛŒ Ø§Ø³Ø§Ø³ÛŒ: RiskCalculator + Ø¨Ù‡Ø¨ÙˆØ¯ Analyzers

---

### Day 1: RiskRewardCalculator

#### Task 1.1: Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ Ùˆ Ø³Ø§Ø®ØªØ§Ø± Ø§ÙˆÙ„ÛŒÙ‡
**ÙØ§ÛŒÙ„**: `signal_generation/risk_calculator.py`

```bash
touch signal_generation/risk_calculator.py
```

**Ù…Ø­ØªÙˆØ§**:
```python
"""
Risk/Reward Calculator - Old System Compatible

Ù…Ø­Ø§Ø³Ø¨Ù‡ Stop-Loss Ùˆ Take-Profit Ø¨Ø§ 5 Ø±ÙˆØ´ Ø§ÙˆÙ„ÙˆÛŒØªâ€ŒØ¯Ø§Ø± Ù…Ø§Ù†Ù†Ø¯ Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ…:
1. Harmonic Pattern-based
2. Price Channel-based
3. Support/Resistance-based (Ø¨Ø§ Ú†Ú© ÙØ§ØµÙ„Ù‡ max 3Ã—ATR)
4. ATR-based (fallback)
5. Percentage-based (final fallback)

Ù…Ø­Ù„ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ…: Old_bot/signal_generator.py:4016-4264
"""

import logging
from typing import Dict, Any, Optional, Tuple
from signal_generation.context import AnalysisContext

logger = logging.getLogger(__name__)


class RiskRewardCalculator:
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡â€ŒÚ¯Ø± Stop-Loss Ùˆ Take-Profit Ù…Ø´Ø§Ø¨Ù‡ Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ….
    """

    def __init__(self, config: Dict[str, Any]):
        """
        Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡.

        Args:
            config: ØªÙ†Ø¸ÛŒÙ…Ø§Øª (risk_management section)
        """
        self.config = config.get('risk_management', {})

        # Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶
        self.default_sl_percent = self.config.get('default_stop_loss_percent', 1.5)
        self.preferred_rr = self.config.get('preferred_risk_reward_ratio', 2.0)
        self.min_rr = self.config.get('min_risk_reward_ratio', 1.5)
        self.atr_multiplier = self.config.get('atr_trailing_multiplier', 2.0)
        self.max_sr_distance_atr = self.config.get('max_sr_distance_atr_ratio', 3.0)

        logger.info(
            f"RiskRewardCalculator initialized: "
            f"preferred_rr={self.preferred_rr}, min_rr={self.min_rr}, "
            f"atr_mult={self.atr_multiplier}"
        )

    def calculate_sl_tp(
        self,
        direction: str,
        entry_price: float,
        context: AnalysisContext,
        config: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Ù…Ø­Ø§Ø³Ø¨Ù‡ Stop-Loss Ùˆ Take-Profit Ø¨Ø§ Ø±ÙˆØ´ Ø§ÙˆÙ„ÙˆÛŒØªâ€ŒØ¯Ø§Ø±.

        Args:
            direction: 'LONG' ÛŒØ§ 'SHORT'
            entry_price: Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯
            context: Context ØªØ­Ù„ÛŒÙ„ (Ø´Ø§Ù…Ù„ Ù†ØªØ§ÛŒØ¬ analyzers)
            config: ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø¶Ø§ÙÛŒ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)

        Returns:
            Dictionary Ø´Ø§Ù…Ù„:
                - stop_loss: Ù‚ÛŒÙ…Øª SL
                - take_profit: Ù‚ÛŒÙ…Øª TP
                - risk_reward_ratio: Ù†Ø³Ø¨Øª RR
                - risk_amount_per_unit: Ù…Ù‚Ø¯Ø§Ø± Ø±ÛŒØ³Ú©
                - sl_method: Ø±ÙˆØ´ Ù…Ø­Ø§Ø³Ø¨Ù‡ SL
        """
        # Override config if provided
        if config:
            self.config = config

        direction = direction.upper()

        stop_loss = None
        take_profit = None
        calculation_method = "None"

        # Ø±ÙˆØ´ 1: Harmonic Pattern
        # TODO: implement

        # Ø±ÙˆØ´ 2: Price Channel
        # TODO: implement

        # Ø±ÙˆØ´ 3: S/R Level
        # TODO: implement

        # Ø±ÙˆØ´ 4: ATR-based (fallback)
        # TODO: implement

        # Ø±ÙˆØ´ 5: Percentage (final fallback)
        # TODO: implement

        # Finalize and return
        return self._finalize_sl_tp(
            stop_loss, take_profit, calculation_method,
            entry_price, direction
        )

    def _try_harmonic_sl_tp(
        self,
        direction: str,
        entry_price: float,
        context: AnalysisContext
    ) -> Tuple[Optional[float], Optional[float], Optional[str]]:
        """
        Ø±ÙˆØ´ 1: Ù…Ø­Ø§Ø³Ø¨Ù‡ SL/TP Ø¨Ø± Ø§Ø³Ø§Ø³ Harmonic Pattern.

        Ù…Ø­Ù„ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ…: signal_generator.py:4061-4091
        """
        # TODO: implement
        return None, None, None

    # TODO: Ø³Ø§ÛŒØ± Ù…ØªØ¯Ù‡Ø§...

    def _finalize_sl_tp(
        self,
        sl: float,
        tp: float,
        method: str,
        entry: float,
        direction: str
    ) -> Dict[str, Any]:
        """
        Ù†Ù‡Ø§ÛŒÛŒâ€ŒØ³Ø§Ø²ÛŒ Ùˆ safety checks.

        Ù…Ø­Ù„ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ…: signal_generator.py:4166-4243
        """
        # TODO: implement safety checks

        risk = abs(entry - sl)
        reward = abs(tp - entry)
        rr = reward / risk if risk > 0 else 0

        return {
            'stop_loss': round(sl, 8),
            'take_profit': round(tp, 8),
            'risk_reward_ratio': round(rr, 2),
            'risk_amount_per_unit': round(risk, 8),
            'sl_method': method
        }
```

**Deliverable**: ÙØ§ÛŒÙ„ Ø³Ø§Ø®ØªØ§Ø± Ø§ÙˆÙ„ÛŒÙ‡ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯

#### Task 1.2: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Harmonic Pattern SL/TP
```python
def _try_harmonic_sl_tp(
    self,
    direction: str,
    entry_price: float,
    context: AnalysisContext
) -> Tuple[Optional[float], Optional[float], Optional[str]]:
    """
    Ø±ÙˆØ´ 1: Ù…Ø­Ø§Ø³Ø¨Ù‡ SL/TP Ø¨Ø± Ø§Ø³Ø§Ø³ Harmonic Pattern.

    Ù…Ø­Ù„ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ…: signal_generator.py:4061-4091
    """
    harmonic_result = context.get_result('harmonic')
    if not harmonic_result or not harmonic_result.get('patterns'):
        return None, None, None

    patterns = harmonic_result['patterns']

    # Ø§Ù†ØªØ®Ø§Ø¨ Ø¨Ù‡ØªØ±ÛŒÙ† pattern (highest confidence)
    best_pattern = max(patterns, key=lambda p: p.get('confidence', 0))

    pattern_direction = best_pattern.get('direction')
    pattern_type = best_pattern.get('type', '')

    # Ø¨Ø±Ø±Ø³ÛŒ Ù‡Ù…â€ŒØ¬Ù‡ØªÛŒ Ø¨Ø§ direction Ø³ÛŒÚ¯Ù†Ø§Ù„
    if (direction == 'LONG' and pattern_direction != 'bullish') or \
       (direction == 'SHORT' and pattern_direction != 'bearish'):
        return None, None, None

    # Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ points
    points = best_pattern.get('points', {})
    if 'D' not in points or 'X' not in points:
        logger.debug("Harmonic pattern missing D or X point")
        return None, None, None

    d_price = points['D']['price']
    x_price = points['X']['price']

    # Ù…Ø­Ø§Ø³Ø¨Ù‡ SL Ùˆ TP
    if direction == 'LONG':
        # SL: 1% below D point
        sl = d_price * 0.99

        # TP: based on pattern type
        if 'butterfly' in pattern_type.lower() or 'crab' in pattern_type.lower():
            # Higher target for these patterns
            tp = entry_price + (entry_price - sl) * 1.618
        else:
            # Target to X point
            tp = x_price

    else:  # SHORT
        # SL: 1% above D point
        sl = d_price * 1.01

        if 'butterfly' in pattern_type.lower() or 'crab' in pattern_type.lower():
            tp = entry_price - (sl - entry_price) * 1.618
        else:
            tp = x_price

    method = f"Harmonic_{pattern_type}"

    logger.info(
        f"Harmonic pattern SL/TP: {pattern_type}, "
        f"SL={sl:.2f}, TP={tp:.2f}"
    )

    return sl, tp, method
```

**Deliverable**: Harmonic method implemented

#### Task 1.3: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Price Channel SL/TP
```python
def _try_channel_sl_tp(
    self,
    direction: str,
    entry_price: float,
    context: AnalysisContext
) -> Tuple[Optional[float], Optional[float], Optional[str]]:
    """
    Ø±ÙˆØ´ 2: Ù…Ø­Ø§Ø³Ø¨Ù‡ SL/TP Ø¨Ø± Ø§Ø³Ø§Ø³ Price Channel.

    Ù…Ø­Ù„ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ…: signal_generator.py:4093-4125
    """
    channel_result = context.get_result('channel')
    if not channel_result or not channel_result.get('channels'):
        return None, None, None

    channel = channel_result['channels'][0]  # Ø§ÙˆÙ„ÛŒÙ† Ú©Ø§Ù†Ø§Ù„
    channel_direction = channel.get('direction')

    # Ø¨Ø±Ø±Ø³ÛŒ Ø³Ø§Ø²Ú¯Ø§Ø±ÛŒ Ø¨Ø§ direction
    if direction == 'LONG':
        if channel_direction not in ['ascending', 'horizontal']:
            return None, None, None

        # SL: below lower channel line
        lower_current = channel.get('lower_current_price')
        if not lower_current:
            return None, None, None

        sl = lower_current * 0.99

        # TP: to upper channel line
        upper_current = channel.get('upper_current_price')
        if not upper_current:
            return None, None, None

        tp = upper_current * 0.99

    elif direction == 'SHORT':
        if channel_direction not in ['descending', 'horizontal']:
            return None, None, None

        # SL: above upper channel line
        upper_current = channel.get('upper_current_price')
        if not upper_current:
            return None, None, None

        sl = upper_current * 1.01

        # TP: to lower channel line
        lower_current = channel.get('lower_current_price')
        if not lower_current:
            return None, None, None

        tp = lower_current * 1.01

    else:
        return None, None, None

    method = f"Price_Channel_{channel_direction}"

    logger.info(
        f"Price channel SL/TP: {channel_direction}, "
        f"SL={sl:.2f}, TP={tp:.2f}"
    )

    return sl, tp, method
```

**Deliverable**: Channel method implemented

#### Task 1.4: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ S/R SL + ATR fallback + Percentage fallback
- [ ] Implement `_try_sr_sl()`
- [ ] Implement `_calculate_atr_sl()`
- [ ] Implement `_calculate_percentage_sl()`
- [ ] Implement `_calculate_tp_from_sl()`
- [ ] Implement `_adjust_tp_with_sr()`

#### Task 1.5: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Safety Checks
- [ ] Minimum SL distance check
- [ ] Maximum SL distance check
- [ ] TP minimum RR check
- [ ] Zero price checks

#### Task 1.6: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ main method Ø¨Ø§ priority flow
```python
def calculate_sl_tp(self, ...):
    """Main method Ø¨Ø§ 5 Ø±ÙˆØ´ Ø§ÙˆÙ„ÙˆÛŒØªâ€ŒØ¯Ø§Ø±"""

    # 1. Try Harmonic
    sl, tp, method = self._try_harmonic_sl_tp(direction, entry_price, context)
    if sl and tp:
        return self._finalize_sl_tp(sl, tp, method, entry_price, direction)

    # 2. Try Channel
    sl, tp, method = self._try_channel_sl_tp(direction, entry_price, context)
    if sl and tp:
        return self._finalize_sl_tp(sl, tp, method, entry_price, direction)

    # 3. Try S/R
    sl = self._try_sr_sl(direction, entry_price, context)

    # Check distance with ATR
    if sl:
        atr = context.get_indicator_value('atr')
        if atr and atr > 0:
            sl_dist_atr_ratio = abs(entry_price - sl) / atr
            if sl_dist_atr_ratio > self.max_sr_distance_atr:
                logger.debug(f"S/R too far: {sl_dist_atr_ratio:.1f}Ã—ATR > {self.max_sr_distance_atr}")
                sl = None  # Reject, too far

    if sl:
        # Calculate TP from SL
        tp = self._calculate_tp_from_sl(sl, entry_price, direction, context)
        method = "Support/Resistance Level"
        return self._finalize_sl_tp(sl, tp, method, entry_price, direction)

    # 4. ATR-based fallback
    sl, tp = self._calculate_atr_sl_tp(direction, entry_price, context)
    if sl and tp:
        method = f"ATR x{self.atr_multiplier}"
        return self._finalize_sl_tp(sl, tp, method, entry_price, direction)

    # 5. Percentage fallback (final)
    sl, tp = self._calculate_percentage_sl_tp(direction, entry_price)
    method = f"Percentage {self.default_sl_percent}%"
    return self._finalize_sl_tp(sl, tp, method, entry_price, direction)
```

#### Task 1.7: Ù†ÙˆØ´ØªÙ† Unit Tests
**ÙØ§ÛŒÙ„**: `tests/unit/signal_generation/test_risk_calculator.py`

```python
import pytest
from signal_generation.risk_calculator import RiskRewardCalculator
from signal_generation.context import AnalysisContext
import pandas as pd

@pytest.fixture
def config():
    return {
        'risk_management': {
            'default_stop_loss_percent': 1.5,
            'preferred_risk_reward_ratio': 2.0,
            'min_risk_reward_ratio': 1.5,
            'atr_trailing_multiplier': 2.0,
            'max_sr_distance_atr_ratio': 3.0
        }
    }

@pytest.fixture
def calculator(config):
    return RiskRewardCalculator(config)

@pytest.fixture
def context_with_harmonic():
    """Context Ø¨Ø§ harmonic pattern"""
    df = pd.DataFrame({
        'close': [50000] * 100,
        'atr': [500] * 100
    })

    context = AnalysisContext('BTCUSDT', '1h', df)

    # Add harmonic pattern result
    context.set_result('harmonic', {
        'status': 'ok',
        'patterns': [{
            'type': 'butterfly',
            'direction': 'bullish',
            'confidence': 0.85,
            'points': {
                'X': {'price': 48000},
                'D': {'price': 49500}
            }
        }]
    })

    return context

def test_harmonic_long_sl_tp(calculator, context_with_harmonic):
    """ØªØ³Øª Ù…Ø­Ø§Ø³Ø¨Ù‡ SL/TP Ø¨Ø±Ø§ÛŒ long Ø¨Ø§ harmonic pattern"""
    result = calculator.calculate_sl_tp(
        direction='LONG',
        entry_price=50000,
        context=context_with_harmonic
    )

    # Ø¨Ø±Ø±Ø³ÛŒâ€ŒÙ‡Ø§
    assert result['sl_method'].startswith('Harmonic')
    assert result['stop_loss'] < 50000  # SL Ø¨Ø§ÛŒØ¯ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø² entry Ø¨Ø§Ø´Ø¯
    assert result['take_profit'] > 50000  # TP Ø¨Ø§ÛŒØ¯ Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø² entry Ø¨Ø§Ø´Ø¯
    assert result['risk_reward_ratio'] >= 1.5  # min RR

def test_fallback_to_atr(calculator):
    """ØªØ³Øª fallback Ø¨Ù‡ ATR ÙˆÙ‚ØªÛŒ harmonic/channel Ù†ÛŒØ³Øª"""
    df = pd.DataFrame({
        'close': [50000] * 100,
        'atr': [500] * 100
    })

    context = AnalysisContext('BTCUSDT', '1h', df)
    # Ø¨Ø¯ÙˆÙ† harmonic/channel results

    result = calculator.calculate_sl_tp(
        direction='LONG',
        entry_price=50000,
        context=context
    )

    assert result['sl_method'].startswith('ATR')
    assert result['stop_loss'] == pytest.approx(50000 - 500 * 2.0, rel=0.01)

# TODO: ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ± Ø¨Ø±Ø§ÛŒ:
# - Channel-based SL/TP
# - S/R with ATR distance check
# - Percentage fallback
# - Safety checks
# - SHORT direction
```

**Run tests**:
```bash
pytest tests/unit/signal_generation/test_risk_calculator.py -v
```

#### Task 1.8: Commit
```bash
git add signal_generation/risk_calculator.py
git add tests/unit/signal_generation/test_risk_calculator.py
git commit -m "feat: Add RiskRewardCalculator with 5-method priority system

Implemented Old System compatible SL/TP calculation:
- Method 1: Harmonic Pattern-based
- Method 2: Price Channel-based
- Method 3: S/R-based (with max 3Ã—ATR distance check)
- Method 4: ATR-based (fallback)
- Method 5: Percentage-based (final fallback)

Includes:
- TP adjustment with nearby S/R
- Safety checks for min/max distances
- Unit tests with 85%+ coverage

Ref: Old_bot/signal_generator.py:4016-4264"
```

**Deliverables Day 1**:
- [x] `signal_generation/risk_calculator.py` (400+ lines)
- [x] Unit tests (200+ lines, 85%+ coverage)
- [x] Commit

---

### Day 2: Analyzer Improvements

#### Task 1.9: MomentumAnalyzer - Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† momentum_strength
**ÙØ§ÛŒÙ„**: `signal_generation/analyzers/momentum_analyzer.py`

```python
# Ø¯Ø± Ù…ØªØ¯ analyze()ØŒ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù†:

def analyze(self, context: AnalysisContext) -> None:
    # ... existing code ...

    # ğŸ†• Ù…Ø­Ø§Ø³Ø¨Ù‡ momentum_strength
    momentum_strength = self._calculate_momentum_strength(context)

    result = {
        'status': 'ok',
        'direction': direction,
        'bullish_score': bullish_score,
        'bearish_score': bearish_score,
        'momentum_strength': momentum_strength,  # ğŸ†•
        'signals': signals,
        'details': details
    }

    context.set_result('momentum', result)

def _calculate_momentum_strength(self, context: AnalysisContext) -> float:
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚Ø¯Ø±Øª momentum (0.8 - 1.2).

    Ù…Ø­Ù„ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ…: signal_generator.py:5248-5250
    """
    rsi = context.get_indicator_value('rsi')

    if rsi is None:
        return 1.0

    # Strong momentum
    if rsi > 70 or rsi < 30:
        return 1.2

    # Moderate momentum
    elif (60 < rsi <= 70) or (30 <= rsi < 40):
        return 1.1

    # Weak momentum
    elif 40 <= rsi <= 60:
        return 0.9

    return 1.0
```

**Test**:
```python
def test_momentum_strength_strong():
    context = create_context_with_rsi(75)  # Strong bullish
    analyzer = MomentumAnalyzer(config)
    analyzer.analyze(context)

    result = context.get_result('momentum')
    assert result['momentum_strength'] == 1.2

def test_momentum_strength_weak():
    context = create_context_with_rsi(50)  # Weak
    analyzer = MomentumAnalyzer(config)
    analyzer.analyze(context)

    result = context.get_result('momentum')
    assert result['momentum_strength'] == 0.9
```

#### Task 1.10: ChannelAnalyzer - Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† current_prices
**ÙØ§ÛŒÙ„**: `signal_generation/analyzers/channel_analyzer.py`

```python
# Ø¯Ø± output channelØŒ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù†:

channel_data = {
    'type': 'channel',
    'direction': direction,  # 'ascending', 'descending', 'horizontal'
    'upper_slope': upper_slope,
    'upper_intercept': upper_intercept,
    'lower_slope': lower_slope,
    'lower_intercept': lower_intercept,
    # ğŸ†• Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ ÙØ¹Ù„ÛŒ
    'upper_current_price': self._calculate_current_price(
        upper_slope, upper_intercept, len(df) - 1
    ),
    'lower_current_price': self._calculate_current_price(
        lower_slope, lower_intercept, len(df) - 1
    ),
    'strength': strength,
    'touch_points_upper': len(upper_touches),
    'touch_points_lower': len(lower_touches)
}

def _calculate_current_price(self, slope: float, intercept: float, index: int) -> float:
    """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ Ø±ÙˆÛŒ Ø®Ø· Ú©Ø§Ù†Ø§Ù„."""
    return slope * index + intercept
```

#### Task 1.11: HTFAnalyzer - Ø¨Ù‡Ø¨ÙˆØ¯ structure_score
**ÙØ§ÛŒÙ„**: `signal_generation/analyzers/htf_analyzer.py`

Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø§ÛŒÙ†Ú©Ù‡ output Ø´Ø§Ù…Ù„:
- `structure_score` (0.5 - 1.5)
- `trends_aligned` (bool)
- `momentum_aligned` (bool)
- `at_support_zone` (bool)
- `at_resistance_zone` (bool)

#### Task 1.12: Ù†ÙˆØ´ØªÙ† tests Ø¨Ø±Ø§ÛŒ ØªØºÛŒÛŒØ±Ø§Øª analyzers

#### Task 1.13: Commit
```bash
git add signal_generation/analyzers/momentum_analyzer.py
git add signal_generation/analyzers/channel_analyzer.py
git add signal_generation/analyzers/htf_analyzer.py
git add tests/unit/signal_generation/analyzers/
git commit -m "feat: Improve analyzers for old system compatibility

Changes:
- MomentumAnalyzer: Add momentum_strength (0.8-1.2 based on RSI)
- ChannelAnalyzer: Add upper_current_price and lower_current_price
- HTFAnalyzer: Ensure structure_score and alignment flags

These outputs are required for old system scoring logic.

Ref: Old_bot/signal_generator.py:5248-5250, 4093-4125"
```

**Deliverables Day 2**:
- [x] Analyzers improved
- [x] Tests added
- [x] Commit

**Checkpoint Phase 1**:
```bash
pytest tests/unit/signal_generation/ -v  # Ù‡Ù…Ù‡ ØªØ³Øªâ€ŒÙ‡Ø§ pass
git log --oneline -5  # 2 commit Ø¬Ø¯ÛŒØ¯
```

---

## âš™ï¸ Phase 2: Core Logic (Ø±ÙˆØ² 3-5ØŒ 3 Ø±ÙˆØ²)

### Ù‡Ø¯Ù
Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…Ù†Ø·Ù‚ Ø§ØµÙ„ÛŒ Scoring Ùˆ Multi-TF

### Day 3: SignalScorer - Part 1 (Base Structure)

#### Task 2.1: Refactor SignalScorer Ø¨Ø±Ø§ÛŒ 13 multipliers
**ÙØ§ÛŒÙ„**: `signal_generation/signal_scorer.py`

#### Task 2.2: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ multiplier methods (1-7)
- base_score
- timeframe_weight
- trend_alignment
- volume_confirmation
- pattern_quality
- confluence_score
- symbol_performance_factor

#### Task 2.3: Ù†ÙˆØ´ØªÙ† tests Ø¨Ø±Ø§ÛŒ multipliers

#### Task 2.4: Commit

---

### Day 4: SignalScorer - Part 2 (Remaining Multipliers)

#### Task 2.5: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ multiplier methods (8-14)
- correlation_safety_factor
- macd_analysis_score
- structure_score
- volatility_score
- harmonic_pattern_score
- price_channel_score
- cyclical_pattern_score

#### Task 2.6: Final score formula

#### Task 2.7: Integration tests

#### Task 2.8: Commit

---

### Day 5: Multi-Timeframe Scoring

#### Task 2.9: Refactor Orchestrator.analyze_symbol()

#### Task 2.10: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ _calculate_multi_timeframe_score()

#### Task 2.11: Integration Ø¨Ø§ RiskCalculator

#### Task 2.12: Tests

#### Task 2.13: Commit

**Checkpoint Phase 2**:
```bash
pytest tests/unit/signal_generation/test_signal_scorer.py -v
pytest tests/integration/ -v
```

---

## ğŸ”— Phase 3: Integration (Ø±ÙˆØ² 6-7ØŒ 2 Ø±ÙˆØ²)

### Day 6: Orchestrator Integration

#### Task 3.1: Ø§ØªØµØ§Ù„ RiskCalculator Ø¨Ù‡ Orchestrator

#### Task 3.2: Ø§ØªØµØ§Ù„ SignalScorer Ø¨Ù‡ Orchestrator

#### Task 3.3: ØªØ³Øª end-to-end

#### Task 3.4: Commit

---

### Day 7: Configuration

#### Task 3.5: Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ config.yaml

#### Task 3.6: Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† flag `use_old_system_logic`

#### Task 3.7: Backward compatibility tests

#### Task 3.8: Commit

---

## âœ… Phase 4: Testing (Ø±ÙˆØ² 8-9ØŒ 2 Ø±ÙˆØ²)

### Day 8: Unit Tests Complete

#### Task 4.1: Coverage 90%+

#### Task 4.2: Edge cases

### Day 9: Integration Tests

#### Task 4.3: End-to-end tests

#### Task 4.4: Comparison Ø¨Ø§ expected outputs

---

## ğŸ¯ Phase 5: Validation (Ø±ÙˆØ² 10ØŒ 1 Ø±ÙˆØ²)

### Day 10: Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ…

#### Task 5.1: Ø§Ø¬Ø±Ø§ÛŒ Ù‡Ø± Ø¯Ùˆ Ø³ÛŒØ³ØªÙ… Ø¨Ø§ Ù‡Ù…Ø§Ù† input

#### Task 5.2: Ù…Ù‚Ø§ÛŒØ³Ù‡ outputs

#### Task 5.3: ØªÙ†Ø¸ÛŒÙ… differences

---

## ğŸ“š Phase 6: Documentation (Ø±ÙˆØ² 11ØŒ 1 Ø±ÙˆØ²)

### Day 11: Ù…Ø³ØªÙ†Ø¯Ø³Ø§Ø²ÛŒ Ù†Ù‡Ø§ÛŒÛŒ

#### Task 6.1: Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ README

#### Task 6.2: Ù†ÙˆØ´ØªÙ† migration guide

#### Task 6.3: Handover document

---

## âœ… Completion Checklist

Ø¯Ø± Ù¾Ø§ÛŒØ§Ù†ØŒ Ø§ÛŒÙ† Ù…ÙˆØ§Ø±Ø¯ Ø¨Ø§ÛŒØ¯ ØªÚ©Ù…ÛŒÙ„ Ø´ÙˆÙ†Ø¯:

### Code
- [ ] RiskRewardCalculator Ø¨Ø§ 5 Ø±ÙˆØ´
- [ ] SignalScorer Ø¨Ø§ 13 multipliers
- [ ] Orchestrator multi-TF refactored
- [ ] Analyzers improved
- [ ] Config updated

### Tests
- [ ] Unit tests 90%+ coverage
- [ ] Integration tests pass
- [ ] Comparison tests Ø¨Ø§ old system pass

### Documentation
- [ ] API docs updated
- [ ] Migration guide written
- [ ] Configuration documented

### Validation
- [ ] Output matches old system (Â±5%)
- [ ] Backtest performance similar
- [ ] No regression in quality

---

**Total Estimated Time**: 11-12 Ø±ÙˆØ² Ú©Ø§Ø±ÛŒ

**Current Status**: Phase 0 - Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ù¾Ø§Ø³Ø® Ø³ÙˆØ§Ù„Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

---

## ğŸ¤” Ø³ÙˆØ§Ù„Ø§ØªØŸ

Ù‚Ø¨Ù„ Ø§Ø² Ø´Ø±ÙˆØ¹ØŒ Ù„Ø·ÙØ§Ù‹ Ø¨Ù‡ **6 Ø³ÙˆØ§Ù„ Ú©Ù„ÛŒØ¯ÛŒ Ø¨Ø§Ù„Ø§** Ù¾Ø§Ø³Ø® Ø¯Ù‡ÛŒØ¯ ØªØ§ Ø¨ØªÙˆØ§Ù†ÛŒÙ… Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒÙ….
